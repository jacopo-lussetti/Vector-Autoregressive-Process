---
title: "Regularised Cov. Estimation"
author: "Jacopo Lussetti"
date: "`r Sys.Date()`"
output:
  html_document: default
headers-includes:
- \usepackage{amsmath}
- \usepackage{amssymb}
bibliography:
  -references.bib
---
```{r, echo=FALSE, message=FALSE, warning=FALSE}}
library(MASS)
library(zoo)
library(stats)
```

This report is aiming at replicating the methodology by \cite{basu2015regularized}
on estimating covaiane matrices and their precision matrices for high-dimensional data.


# Exercise 1 

#Data Generation
To simulate the stochastic regression model, we will generate data from our code
that allows to randomly generate an uppper triangle coefficient matrix. Then we
will simulate the data with a VAR(1) model. Then we will proceed to use a 
Gaussian VAR(1) model $X^t=AX^{t-1} + \epsilon^t, \quad \epsilon^t \overset{\text{i.i.d.}}{\sim}\mathcal{N}(\alpha I_{Kp})$, where $\alpha =0.2$
```{r}
#we define first of all the various functions
##Simulation upper triangular matrix
### To ensure that process is stable, we need to check the abs of eigenvalue
stab_test <- function(kp, A, tol = 1e-8)
{
  if (!is.matrix(A) || nrow(A) != ncol(A)) {
    stop("The matrix is not square")
  }
  eig <- eigen(A, only.values = TRUE)$values  # computing the eigenvalues
  
  for (i in 1:length(eig)) {     
    if (Mod(eig[i]) >= 1 - tol) { # Mod to handle complex numbers
      return(FALSE)               
    }
  }
  return(TRUE)
}


A_sim <- function(K, spar, sd, max_tries = 1000){ #parameter spar determines
  #how many elements will be set to zero
  tries <- 0 
  repeat{
    A <- matrix(0L, K, K)
    idx_up <- which(upper.tri(A))
    n_up   <- length(idx_up)

    if (n_up > 0) {
      A[idx_up] <- rnorm(n_up, mean = 0, sd = sd)   #fill the upper 
  #triangle with r.v. from a normal distribution
  #cancel a certain percentage of the elements
      nmiss <- round(n_up * spar)
      if (nmiss > 0) { # add sparsity
        zero_idx <- sample(idx_up, nmiss, replace = FALSE)
        A[zero_idx] <- 0
      }
    }

    # we apply the formula previously defined to check stability
    if (stab_test(K, A) == TRUE) return(A)
     # else try again
    tries <- tries + 1
    #to prevent infinite loop due to using repeat loop, we set a max number of
    #iterations
    if (tries >= max_tries) {
      stop("Could not generate a stable A within max_tries.")
    }
  }
}
## VAR(p) process Simulator
var_sim <- function(AA, nu, Sigma_u, nSteps, y0) {
    K <- nrow(Sigma_u)
    Kp <- ncol(AA)
    p <- Kp/K
        
    if (p > 1) {
        C <- comp_mtrx(AA) # form the  companion matrix of the var(p) process
    } else {
        C <- AA  
    }
    y_t <- matrix(0, nrow =  nSteps, ncol=Kp) #trajectories matrix nSteps x Kp
    y_t[1, 1:Kp] <- y0 #add initial value to initiate the simulation
    noise <- mvrnorm(n = nSteps, mu = rep(0, K), Sigma = Sigma_u) #assuming that 
    #residuals follow a multivariate normal distribution    
    
    for (t in 2:nSteps) {
        y_t[t, ] <- C %*% y_t[t-1, ]
        y_t[t, 1:K] <- y_t[t, 1:K] + nu + noise[t,]
    }
    
    y_t <- zoo(y_t[,1:K], 1:nSteps)  
    return(y_t)
  }
```

```{r}
#We simulate the VAR(1) model
#we first simulate a 
K<-200
A_true<-A_sim(K, spar=0, sd=0.2)
#generate res covariance matrix assuming indendence & Gaussianity 
cov_res<-diag(0.2, nrow=K,ncol=K)
#generate a var(1)
```

```{r}  
#simulation, we first try with small n
set.seed(123)
T_steps<-600
coef_matrix<-diag(0.2, nrow=,ncol=5)

```